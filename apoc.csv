type,name,text,signature,roles,writes,core
procedure,apoc.algo.aStar,"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function","apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)",null,null,true
procedure,apoc.algo.aStarConfig,"apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function","apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)",null,null,true
procedure,apoc.algo.allSimplePaths,"apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes","apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)",null,null,true
procedure,apoc.algo.cover,apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes,apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?),null,null,true
procedure,apoc.algo.dijkstra,"apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function","apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight = NaN :: FLOAT?, numberOfWantedPaths = 1 :: INTEGER?) :: (path :: PATH?, weight :: FLOAT?)",null,null,true
procedure,apoc.algo.dijkstraWithDefaultWeight,"apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist","apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)",null,null,true
procedure,apoc.atomic.add,"apoc.atomic.add(node/relatonship,propertyName,number) Sums the property's value with the 'number' value ","apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.atomic.concat,"apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property's value with the 'string' value","apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.atomic.insert,"apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property's array value at 'position'","apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.atomic.remove,"apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position 'position'","apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.atomic.subtract,"apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the 'number' value to the property's value","apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.atomic.update,"apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property's value with a cypher operation (ex. ""n.prop1+n.prop2"")","apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",null,null,true
procedure,apoc.bolt.execute,"apoc.bolt.execute(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for reads and writes","apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.bolt.load,"apoc.bolt.load(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read","apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.bolt.load.fromLocal,"","apoc.bolt.load.fromLocal(url :: STRING?, localStatement :: STRING?, remoteStatement :: STRING?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.case,"apoc.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / read-only query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters","apoc.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.cluster.graph,"","apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,false
procedure,apoc.coll.elements,"apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type","apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)",null,null,true
procedure,apoc.coll.pairWithOffset,"apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset","apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.coll.partition,"apoc.coll.partition(list,batchSize)","apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.coll.split,"apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists","apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.coll.zipToRows,"apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair","apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.config.list,"apoc.config.list | Lists the Neo4j configuration as key,value table","apoc.config.list() :: (key :: STRING?, value :: ANY?)",null,null,false
procedure,apoc.config.map,apoc.config.map | Lists the Neo4j configuration as map,apoc.config.map() :: (value :: MAP?),null,null,false
procedure,apoc.convert.setJsonProperty,"apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node","apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID",null,null,true
procedure,apoc.convert.toTree,"apoc.convert.toTree([paths],[lowerCaseRels=true], [config]) creates a stream of nested documents representing the at least one root of these paths","apoc.convert.toTree(paths :: LIST? OF PATH?, lowerCaseRels = true :: BOOLEAN?, config = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.couchbase.append,"apoc.couchbase.append(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.","apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?, config = {} :: MAP?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.exists,"apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.","apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.couchbase.get,"apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.","apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.insert,"apoc.couchbase.insert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.","apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.namedParamsQuery,"apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.","apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",null,null,false
procedure,apoc.couchbase.posParamsQuery,"apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.","apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",null,null,false
procedure,apoc.couchbase.prepend,"apoc.couchbase.prepend(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.","apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?, config = {} :: MAP?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.query,"apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.","apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",null,null,false
procedure,apoc.couchbase.remove,"apoc.couchbase.remove(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.","apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.replace,"apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.","apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.couchbase.upsert,"apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.","apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",null,null,false
procedure,apoc.create.addLabels,"apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes","apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.clonePathToVirtual,apoc.create.clonePathToVirtual,apoc.create.clonePathToVirtual(path :: PATH?) :: (path :: PATH?),null,null,true
procedure,apoc.create.clonePathsToVirtual,apoc.create.clonePathsToVirtual,apoc.create.clonePathsToVirtual(paths :: LIST? OF PATH?) :: (path :: PATH?),null,null,true
procedure,apoc.create.node,"apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels","apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.nodes,"apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels","apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.relationship,"apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type","apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.create.removeLabels,"apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes","apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.removeProperties,"apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given properties from the nodes(s)","apoc.create.removeProperties(nodes :: ANY?, keys :: LIST? OF STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.removeRelProperties,"apoc.create.removeRelProperties( [rel,id,ids,rels], [keys]) - removes the given properties from the relationship(s)","apoc.create.removeRelProperties(rels :: ANY?, keys :: LIST? OF STRING?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.create.setLabels,"apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes","apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.setProperties,"apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given properties on the nodes(s)","apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.setProperty,"apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)","apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.setRelProperties,"apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given properties on the relationship(s)","apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.create.setRelProperty,"apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)","apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.create.uuids,apoc.create.uuids(count) yield uuid - creates 'count' UUIDs ,"apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)",null,null,true
procedure,apoc.create.vNode,"apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node","apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.vNodes,"apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes","apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.create.vPattern,"apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern","apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",null,null,true
procedure,apoc.create.vPatternFull,"apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern","apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",null,null,true
procedure,apoc.create.vRelationship,"apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship","apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.create.virtualPath,"apoc.create.virtualPath(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual path of nodes joined by a relationship and the associated properties","apoc.create.virtualPath(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",null,null,true
procedure,apoc.custom.asFunction,"apoc.custom.asFunction(name, statement, outputs, inputs, forceSingle, description) - register a custom cypher function","apoc.custom.asFunction(name :: STRING?, statement :: STRING?, outputs =  :: STRING?, inputs = null :: LIST? OF LIST? OF STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID",null,null,false
procedure,apoc.custom.asProcedure,"apoc.custom.asProcedure(name, statement, mode, outputs, inputs, description) - register a custom cypher procedure","apoc.custom.asProcedure(name :: STRING?, statement :: STRING?, mode = read :: STRING?, outputs = null :: LIST? OF LIST? OF STRING?, inputs = null :: LIST? OF LIST? OF STRING?, description =  :: STRING?) :: VOID",null,null,false
procedure,apoc.custom.declareFunction,"apoc.custom.declareFunction(signature, statement, forceSingle, description) - register a custom cypher function","apoc.custom.declareFunction(signature :: STRING?, statement :: STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID",null,null,false
procedure,apoc.custom.declareProcedure,"apoc.custom.declareProcedure(signature, statement, mode, description) - register a custom cypher procedure","apoc.custom.declareProcedure(signature :: STRING?, statement :: STRING?, mode = read :: STRING?, description =  :: STRING?) :: VOID",null,null,false
procedure,apoc.custom.list,apoc.custom.list() - provide a list of custom procedures/function registered,"apoc.custom.list() :: (type :: STRING?, name :: STRING?, description :: STRING?, mode :: STRING?, statement :: STRING?, inputs :: LIST? OF LIST? OF STRING?, outputs :: ANY?, forceSingle :: BOOLEAN?)",null,null,false
procedure,apoc.custom.removeFunction,"apoc.custom.removeFunction(name, type) - remove the targeted custom function",apoc.custom.removeFunction(name :: STRING?) :: VOID,null,null,false
procedure,apoc.custom.removeProcedure,apoc.custom.removeProcedure(name) - remove the targeted custom procedure,apoc.custom.removeProcedure(name :: STRING?) :: VOID,null,null,false
procedure,apoc.cypher.doIt,"apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters","apoc.cypher.doIt(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.cypher.mapParallel,"apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _","apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)",null,null,false
procedure,apoc.cypher.mapParallel2,"apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _","apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout = 10 :: INTEGER?) :: (value :: MAP?)",null,null,false
procedure,apoc.cypher.parallel,"","apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",null,null,false
procedure,apoc.cypher.parallel2,"","apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",null,null,false
procedure,apoc.cypher.run,"apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters - currently no schema operations","apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.cypher.runFile,"apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations","apoc.cypher.runFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",null,null,false
procedure,apoc.cypher.runFiles,"apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated","apoc.cypher.runFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",null,null,false
procedure,apoc.cypher.runMany,"apoc.cypher.runMany('cypher;\nstatements;',{params},[{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations","apoc.cypher.runMany(cypher :: STRING?, params :: MAP?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",null,null,true
procedure,apoc.cypher.runSchema,"apoc.cypher.runSchema(statement, params) yield value - executes query schema statement with the given parameters","apoc.cypher.runSchema(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.cypher.runSchemaFile,"apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated","apoc.cypher.runSchemaFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",null,null,false
procedure,apoc.cypher.runSchemaFiles,"apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated","apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",null,null,false
procedure,apoc.cypher.runTimeboxed,"apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort kernelTransaction after timeout ms if not finished","apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)",null,null,true
procedure,apoc.cypher.runWrite,"apoc.cypher.runWrite(statement, params) yield value - alias for apoc.cypher.doIt","apoc.cypher.runWrite(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.date.expire,"CALL apoc.date.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property","apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID",null,null,false
procedure,apoc.date.expireIn,"CALL apoc.date.expireIn(node,time,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property","apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID",null,null,false
procedure,apoc.do.case,"apoc.do.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / writing query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters","apoc.do.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.do.when,"apoc.do.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes writing ifQuery or elseQuery with the given parameters","apoc.do.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.dv.catalog.add,Add a virtualized resource configuration,"apoc.dv.catalog.add(name :: STRING?, config = {} :: MAP?) :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",null,null,false
procedure,apoc.dv.catalog.list,List all virtualized resource configuration,"apoc.dv.catalog.list() :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",null,null,false
procedure,apoc.dv.catalog.remove,Remove a virtualized resource config by name,"apoc.dv.catalog.remove(name :: STRING?) :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",null,null,false
procedure,apoc.dv.query,Query a virtualized resource by name and return virtual nodes,"apoc.dv.query(name :: STRING?, params = {} :: ANY?, config = {} :: MAP?) :: (node :: NODE?)",null,null,false
procedure,apoc.dv.queryAndLink,Query a virtualized resource by name and return virtual nodes linked using virtual rels to the node passed as first param,"apoc.dv.queryAndLink(node :: NODE?, relName :: STRING?, name :: STRING?, params = {} :: ANY?, config = {} :: MAP?) :: (path :: PATH?)",null,null,false
procedure,apoc.es.get,"apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search","apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.getRaw,"apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search","apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.post,"apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search","apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.postRaw,"apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search","apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.put,"apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search","apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.query,"apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search","apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",null,null,false
procedure,apoc.es.stats,apoc.es.stats(host-url-Key) - elastic search statistics,apoc.es.stats(host :: STRING?) :: (value :: MAP?),null,null,false
procedure,apoc.example.movies,apoc.example.movies() | Creates the sample movies graph,"apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.csv.all,"apoc.export.csv.all(file,config) - exports whole database as csv to the provided file","apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.csv.data,"apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file","apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.csv.graph,"apoc.export.csv.graph(graph,file,config) - exports given graph object as csv to the provided file","apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.csv.query,"apoc.export.csv.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as csv to the provided file","apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.cypher.all,"apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file","apoc.export.cypher.all(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypher.data,"apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file","apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypher.graph,"apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file","apoc.export.cypher.graph(graph :: MAP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypher.query,"apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file","apoc.export.cypher.query(query :: STRING?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypher.schema,"apoc.export.cypher.schema(file,config) - exports all schema indexes and constraints to cypher","apoc.export.cypher.schema(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypherAll,"apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file","apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypherData,"apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file","apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypherGraph,"apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file","apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.cypherQuery,"apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file","apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)",null,null,true
procedure,apoc.export.graphml.all,"apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file","apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.graphml.data,"apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file","apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.graphml.graph,"apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file","apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.graphml.query,"apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file","apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.json.all,"apoc.export.json.all(file,config) - exports whole database as json to the provided file","apoc.export.json.all(file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.json.data,"apoc.export.json.data(nodes,rels,file,config) - exports given nodes and relationships as json to the provided file","apoc.export.json.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.json.graph,"apoc.export.json.graph(graph,file,config) - exports given graph object as json to the provided file","apoc.export.json.graph(graph :: MAP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.export.json.query,"apoc.export.json.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as json to the provided file","apoc.export.json.query(query :: STRING?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.generate.ba,"apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model","apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",null,null,false
procedure,apoc.generate.complete,"apoc.generate.complete(noNodes, label, type) - generates a random complete graph","apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",null,null,false
procedure,apoc.generate.er,"apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model","apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",null,null,false
procedure,apoc.generate.simple,"apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution","apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID",null,null,false
procedure,apoc.generate.ws,"apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model","apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID",null,null,false
procedure,apoc.gephi.add,"apoc.gephi.add(url-or-key, workspace, data, weightproperty, ['exportproperty']) | streams passed in data to Gephi","apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty = null :: STRING?, exportproperties = [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,false
procedure,apoc.get.nodes,apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's,apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?),null,null,false
procedure,apoc.get.rels,apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's,apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?),null,null,false
procedure,apoc.graph.from,"apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in","apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromCypher,"apoc.graph.fromCypher('kernelTransaction',{params},'name',{properties}) - creates a virtual graph object for later processing","apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromDB,"apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing","apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromData,"apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing","apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromDocument,"apoc.graph.fromDocument({json}, {config}) yield graph - transform JSON documents into graph structures","apoc.graph.fromDocument(json :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromPath,"apoc.graph.fromPath(path,'name',{properties}) - creates a virtual graph object for later processing","apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.fromPaths,"apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing","apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",null,null,true
procedure,apoc.graph.validateDocument,"apoc.graph.validateDocument({json}, {config}) yield row - validates the json, return the result of the validation","apoc.graph.validateDocument(json :: ANY?, config = {} :: MAP?) :: (row :: MAP?)",null,null,true
procedure,apoc.help,"Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.","apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?, core :: BOOLEAN?)",null,null,true
procedure,apoc.import.csv,"apoc.import.csv(nodes, relationships, config) - imports nodes and relationships from the provided CSV files with given labels and types","apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.import.graphml,"apoc.import.graphml(urlOrBinaryFile,config) - imports graphml file","apoc.import.graphml(urlOrBinaryFile :: ANY?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.import.json,"apoc.import.json(urlOrBinaryFile,config) - imports the json list to the provided file","apoc.import.json(urlOrBinaryFile :: ANY?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)",null,null,true
procedure,apoc.import.xml,"apoc.import.xml(file,config) - imports graph from provided file","apoc.import.xml(urlOrBinary :: ANY?, config = {} :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.load.csv,"apoc.load.csv('urlOrBinary',{config}) YIELD lineNo, list, map - load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}","apoc.load.csv(urlOrBinary :: ANY?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)",null,null,false
procedure,apoc.load.csvParams,"apoc.load.csvParams('urlOrBinary', {httpHeader: value}, payload, {config}) YIELD lineNo, list, map - load from CSV URL (e.g. web-api) while sending headers / payload to load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}","apoc.load.csvParams(urlOrBinary :: ANY?, httpHeaders :: MAP?, payload :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)",null,null,false
procedure,apoc.load.directory,"apoc.load.directory('pattern', 'urlDir', {config}) YIELD value - Loads list of all files in folder specified by urlDir or in import folder if urlDir string is empty or not specified","apoc.load.directory(pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (value :: STRING?)",null,null,false
procedure,apoc.load.directory.async.add,"apoc.load.directory.async.add(name, cypher, pattern, urlDir, {}) YIELD name, status, pattern, cypher, urlDir, config, error - Add or replace a folder listener with a specific name, pattern and url directory that execute the specified cypher query when an event is triggered and return listener list","apoc.load.directory.async.add(name :: STRING?, cypher :: STRING?, pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",null,null,false
procedure,apoc.load.directory.async.list,"apoc.load.directory.async.list() YIELD name, status, pattern, cypher, urlDir, config, error - List of all folder listeners","apoc.load.directory.async.list() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",null,null,false
procedure,apoc.load.directory.async.remove,"apoc.load.directory.async.remove(name) YIELD name, status, pattern, cypher, urlDir, config, error - Remove a folder listener by name and return remaining listeners, if any","apoc.load.directory.async.remove(name :: STRING?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",null,null,false
procedure,apoc.load.directory.async.removeAll,apoc.load.directory.async.removeAll() - Remove all folder listeners,"apoc.load.directory.async.removeAll() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",null,null,false
procedure,apoc.load.driver,apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database,apoc.load.driver(driverClass :: STRING?) :: VOID,null,null,false
procedure,apoc.load.html,"apoc.load.html('url',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map","apoc.load.html(url :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.load.jdbc,"apoc.load.jdbc('key or url','table or statement', params, config) YIELD row - load from relational database, from a full table or a sql statement","apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.load.jdbcParams,"deprecated - please use: apoc.load.jdbc('key or url','',[params]) YIELD row - load from relational database, from a sql statement with parameters","apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.load.jdbcUpdate,"apoc.load.jdbcUpdate('key or url','statement',[params],config) YIELD row - update relational database, from a SQL statement with optional parameters","apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.load.json,"apoc.load.json('urlOrKeyOrBinary',path, config) YIELD value - import JSON as stream of values if the JSON was an array or a single value if it was a map","apoc.load.json(urlOrKeyOrBinary :: ANY?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.load.jsonArray,apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values,"apoc.load.jsonArray(url :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",null,null,true
procedure,apoc.load.jsonParams,"apoc.load.jsonParams('urlOrKeyOrBinary',{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map","apoc.load.jsonParams(urlOrKeyOrBinary :: ANY?, headers :: MAP?, payload :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.load.ldap,"apoc.load.ldap(""key"" or {connectionMap},{searchMap}) Load entries from an ldap source (yield entry)","apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)",null,null,false
procedure,apoc.load.xml,"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name - load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.","apoc.load.xml(urlOrBinary :: ANY?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (value :: MAP?)",null,null,true
procedure,apoc.lock.all,"apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships","apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID",null,null,true
procedure,apoc.lock.nodes,apoc.lock.nodes([nodes]) acquires a write lock on the given nodes,apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID,null,null,true
procedure,apoc.lock.read.nodes,apoc.lock.read.nodes([nodes]) acquires a read lock on the given nodes,apoc.lock.read.nodes(nodes :: LIST? OF NODE?) :: VOID,null,null,true
procedure,apoc.lock.read.rels,apoc.lock.read.rels([relationships]) acquires a read lock on the given relationship,apoc.lock.read.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID,null,null,true
procedure,apoc.lock.rels,apoc.lock.rels([relationships]) acquires a write lock on the given relationship,apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID,null,null,true
procedure,apoc.log.debug,"apoc.log.debug(message, params) - logs debug message","apoc.log.debug(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",null,null,false
procedure,apoc.log.error,"apoc.log.error(message, params) - logs error message","apoc.log.error(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",null,null,false
procedure,apoc.log.info,"apoc.log.info(message, params) - logs info message","apoc.log.info(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",null,null,false
procedure,apoc.log.stream,"apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines","apoc.log.stream(path :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, line :: STRING?, path :: STRING?)",null,null,true
procedure,apoc.log.warn,"apoc.log.warn(message, params) - logs warn message","apoc.log.warn(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",null,null,false
procedure,apoc.math.regr,"apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label","apoc.math.regr(label :: STRING?, propertyY :: STRING?, propertyX :: STRING?) :: (r2 :: FLOAT?, avgX :: FLOAT?, avgY :: FLOAT?, slope :: FLOAT?)",null,null,true
procedure,apoc.merge.node,"""apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes with dynamic labels, with support for setting properties ON CREATE or ON MATCH","apoc.merge.node(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.merge.node.eager,"apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes eagerly, with dynamic labels, with support for setting properties ON CREATE or ON MATCH","apoc.merge.node.eager(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.merge.relationship,"apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH","apoc.merge.relationship(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.merge.relationship.eager,"apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH","apoc.merge.relationship.eager(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.meta.data,apoc.meta.data({config})  - examines a subset of the graph to provide a tabular meta information,"apoc.meta.data(config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)",null,null,true
procedure,apoc.meta.data.of,"apoc.meta.data.of({graph}, {config})  - examines a subset of the graph to provide a tabular meta information","apoc.meta.data.of(graph :: ANY?, config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)",null,null,true
procedure,apoc.meta.graph,apoc.meta.graph - examines the full graph to create the meta-graph,"apoc.meta.graph(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.meta.graph.of,"apoc.meta.graph.of({graph}, {config})  - examines a subset of the graph to provide a graph meta information","apoc.meta.graph.of(graph = {} :: ANY?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.meta.graphSample,"apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships","apoc.meta.graphSample(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.meta.nodeTypeProperties,apoc.meta.nodeTypeProperties(),"apoc.meta.nodeTypeProperties(config = {} :: MAP?) :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)",null,null,true
procedure,apoc.meta.relTypeProperties,apoc.meta.relTypeProperties(),"apoc.meta.relTypeProperties(config = {} :: MAP?) :: (relType :: STRING?, sourceNodeLabels :: LIST? OF STRING?, targetNodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)",null,null,true
procedure,apoc.meta.schema,apoc.meta.schema({config})  - examines a subset of the graph to provide a map-like meta information,apoc.meta.schema(config = {} :: MAP?) :: (value :: MAP?),null,null,true
procedure,apoc.meta.stats,"apoc.meta.stats yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics","apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, relTypesCount :: MAP?, stats :: MAP?)",null,null,true
procedure,apoc.meta.subGraph,"apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph","apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.metrics.get,"apoc.metrics.get(metricName, {}) - retrieve a system metric by its metric name. Additional configuration options may be passed matching the options available for apoc.load.csv.","apoc.metrics.get(metricName :: STRING?, config = {} :: MAP?) :: (timestamp :: INTEGER?, metric :: STRING?, map :: MAP?)",null,null,false
procedure,apoc.metrics.list,apoc.metrics.list() - get a list of available metrics,"apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)",null,null,false
procedure,apoc.metrics.storage,"apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as 'dbms.directories.data'.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are **not** paths, they are a neo4j.conf setting key name","apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)",null,null,false
procedure,apoc.model.jdbc,"apoc.model.jdbc('key or url', {schema:'<schema>', write: <true/false>, filters: { tables:[], views: [], columns: []}) YIELD nodes, relationships - load schema from relational database","apoc.model.jdbc(jdbc :: STRING?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,false
procedure,apoc.mongo.aggregate,"apoc.mongo.aggregate(uri, pipeline, $config) yield value - perform an aggregate operation on mongodb collection","apoc.mongo.aggregate(uri :: STRING?, pipeline :: LIST? OF MAP?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongo.count,"apoc.mongo.count(uri, query, $config) yield value - perform a count operation on mongodb collection","apoc.mongo.count(uri :: STRING?, query :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.mongo.delete,"apoc.mongo.delete(uri, query, $config) - delete the given documents from the mongodb collection and returns the number of affected documents","apoc.mongo.delete(uri :: STRING?, query :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.mongo.find,"apoc.mongo.find(uri, query, $config) yield value - perform a find operation on mongodb collection","apoc.mongo.find(uri :: STRING?, query = null :: ANY?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongo.insert,"apoc.mongo.insert(uri, documents, $config) yield value - inserts the given documents into the mongodb collection","apoc.mongo.insert(uri :: STRING?, documents :: LIST? OF ANY?, config = {} :: MAP?) :: VOID",null,null,false
procedure,apoc.mongo.update,"apoc.mongo.update(uri, query, update, $config) - updates the given documents from the mongodb collection and returns the number of affected documents","apoc.mongo.update(uri :: STRING?, query :: ANY?, update :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.mongodb.count,"apoc.mongodb.count(host-or-key,db,collection,query) yield value - perform a find operation on mongodb collection","apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.mongodb.delete,"apoc.mongodb.delete(host-or-key,db,collection,query) - delete the given documents from the mongodb collection and returns the number of affected documents","apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.mongodb.find,"apoc.mongodb.find(host-or-key,db,collection,query,projection,sort,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find,project,sort operation on mongodb collection","apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongodb.first,"apoc.mongodb.first(host-or-key,db,collection,query,[compatibleValues=false|true],[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a first operation on mongodb collection","apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = true :: BOOLEAN?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongodb.get,"apoc.mongodb.get(host-or-key,db,collection,query,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find operation on mongodb collection","apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongodb.get.byObjectId,"apoc.mongodb.get.byObjectId(hostOrKey, db, collection, objectIdValue, config(default:{})) - get the document by Object id value","apoc.mongodb.get.byObjectId(host :: STRING?, db :: STRING?, collection :: STRING?, objectIdValue :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.mongodb.insert,"apoc.mongodb.insert(host-or-key,db,collection,documents) - inserts the given documents into the mongodb collection","apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID",null,null,false
procedure,apoc.mongodb.update,"apoc.mongodb.update(host-or-key,db,collection,query,update) - updates the given documents from the mongodb collection and returns the number of affected documents","apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.monitor.ids,apoc.monitor.ids() returns the object ids in use for this neo4j instance,"apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)",null,null,false
procedure,apoc.monitor.kernel,apoc.monitor.kernel() returns informations about the neo4j kernel,"apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)",null,null,false
procedure,apoc.monitor.store,apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store,"apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)",null,null,false
procedure,apoc.monitor.tx,apoc.monitor.tx() returns informations about the neo4j transaction manager,"apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)",null,null,false
procedure,apoc.neighbors.athop,"apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.athop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)",null,null,true
procedure,apoc.neighbors.athop.count,"apoc.neighbors.athop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.athop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)",null,null,true
procedure,apoc.neighbors.byhop,"apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.byhop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (nodes :: LIST? OF NODE?)",null,null,true
procedure,apoc.neighbors.byhop.count,"apoc.neighbors.byhop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.byhop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.neighbors.tohop,"apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.tohop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)",null,null,true
procedure,apoc.neighbors.tohop.count,"apoc.neighbors.tohop.count(node, rel-direction-pattern, distance) - returns distinct count of nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships","apoc.neighbors.tohop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)",null,null,true
procedure,apoc.nodes.collapse,"apoc.nodes.collapse([nodes...],[{properties:'overwrite' or 'discard' or 'combine'}]) yield from, rel, to merge nodes onto first in list","apoc.nodes.collapse(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",null,null,true
procedure,apoc.nodes.cycles,"CALL apoc.nodes.cycles([nodes], $config) - Detect all path cycles from node list","apoc.nodes.cycles(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (path :: PATH?)",null,null,true
procedure,apoc.nodes.delete,apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these ids,"apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)",null,null,true
procedure,apoc.nodes.get,apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these ids,apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?),null,null,true
procedure,apoc.nodes.group,"","apoc.nodes.group(labels :: LIST? OF STRING?, groupByProperties :: LIST? OF STRING?, aggregations = [{*=count}, {*=count}] :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, node :: NODE?, relationship :: RELATIONSHIP?)",null,null,true
procedure,apoc.nodes.link,"apoc.nodes.link([nodes],'REL_TYPE', conf) - creates a linked list of nodes from first to last","apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?, config = {} :: MAP?) :: VOID",null,null,true
procedure,apoc.nodes.rels,apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these ids,apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?),null,null,true
procedure,apoc.path.expand,"apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters","apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)",null,null,true
procedure,apoc.path.expandConfig,"apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters. ","apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)",null,null,true
procedure,apoc.path.spanningTree,"apoc.path.spanningTree(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters","apoc.path.spanningTree(start :: ANY?, config :: MAP?) :: (path :: PATH?)",null,null,true
procedure,apoc.path.subgraphAll,"apoc.path.subgraphAll(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph","apoc.path.subgraphAll(start :: ANY?, config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.path.subgraphNodes,"apoc.path.subgraphNodes(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters","apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.periodic.cancel,apoc.periodic.cancel(name) - cancel job with the given name,"apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.commit,"apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0","apoc.periodic.commit(statement :: STRING?, params = {} :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, failedBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?, wasTerminated :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.countdown,"apoc.periodic.countdown('name',statement,repeat-rate-in-seconds) submit a repeatedly-called background statement until it returns 0","apoc.periodic.countdown(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.iterate,"apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows","apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)",null,null,true
procedure,apoc.periodic.list,apoc.periodic.list - list all jobs,"apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.repeat,"apoc.periodic.repeat('name',statement,repeat-rate-in-seconds, config) submit a repeatedly-called background statement. Fourth parameter 'config' is optional and can contain 'params' entry for nested statement.","apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?, config = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.rock_n_roll,"apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows","apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)",null,null,false
procedure,apoc.periodic.rock_n_roll_while,"apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows","apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)",null,null,false
procedure,apoc.periodic.submit,"apoc.periodic.submit('name',statement,params) - submit a one-off background statement; parameter 'params' is optional and can contain query parameters for Cypher statement","apoc.periodic.submit(name :: STRING?, statement :: STRING?, params = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",null,null,true
procedure,apoc.periodic.truncate,apoc.periodic.truncate({config}) - removes all entities (and optionally indexes and constraints) from db using the apoc.periodic.iterate under the hood,apoc.periodic.truncate(config = {} :: MAP?) :: VOID,null,null,true
procedure,apoc.redis.append,"apoc.redis.append(uri, key, value, {config}) | Execute the 'APPEND key value' command","apoc.redis.append(uri :: STRING?, key :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.configGet,"apoc.redis.configGet(uri, parameter, {config}) | Execute the 'CONFIG GET parameter' command","apoc.redis.configGet(uri :: STRING?, parameter :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.redis.configSet,"apoc.redis.configSet(uri, parameter, {config}) | Execute the 'CONFIG SET parameter value' command","apoc.redis.configSet(uri :: STRING?, parameter :: STRING?, value :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.copy,"apoc.redis.copy(uri, source, destination, {config}) | Execute the 'COPY source destination' command and returns true if source was copied and false otherwise","apoc.redis.copy(uri :: STRING?, source :: ANY?, destination :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.redis.eval,"apoc.redis.eval(uri, script, outputType, keys, values, {config}) | Execute the 'EVAL script' command. In the parameters provided to the procedure, keys are bound to the KEYS[n] like special array of the Lua script and values are bound to the ARGV[n] like special array of the Lua script.","apoc.redis.eval(uri :: STRING?, script :: STRING?, outputType :: STRING?, keys :: LIST? OF ANY?, values :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.exists,"apoc.redis.exists(uri, keys, {config}) | Execute the 'EXISTS keys' command","apoc.redis.exists(uri :: STRING?, keys :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.get,"apoc.redis.get(uri, key, {config}) | Execute the 'GET key' command","apoc.redis.get(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.getSet,"apoc.redis.getSet(uri, key, value, {config}) | Execute the 'SET key value' command and return old value stored (or null if did not exists)","apoc.redis.getSet(uri :: STRING?, key :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.hdel,"apoc.redis.hdel(uri, key, fields, {config}) | Execute the 'HDEL key fields' command","apoc.redis.hdel(uri :: STRING?, key :: ANY?, fields :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.hexists,"apoc.redis.hexists(uri, key, field, {config}) | Execute the 'HEXISTS key field' command","apoc.redis.hexists(uri :: STRING?, key :: ANY?, field :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.redis.hget,"apoc.redis.hget(uri, key, field, {config}) | Execute the 'HGET key field' command","apoc.redis.hget(uri :: STRING?, key :: ANY?, field :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.hgetall,"apoc.redis.hgetall(uri, key, {config}) | Execute the 'HGETALL key' command","apoc.redis.hgetall(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: MAP?)",null,null,false
procedure,apoc.redis.hincrby,"apoc.redis.hincrby(uri, key, field, amount, {config}) | Execute the 'HINCRBY key field amount' command","apoc.redis.hincrby(uri :: STRING?, key :: ANY?, field :: ANY?, amount :: INTEGER?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.hset,"apoc.redis.hset(uri, key, field, value, {config}) | Execute the 'HSET key field value' command and returns true if it is a new field in the hash or false if the field already exists","apoc.redis.hset(uri :: STRING?, key :: ANY?, field :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.redis.incrby,"apoc.redis.incrby(uri, key, amount, {config}) | Execute the 'INCRBY key increment' command","apoc.redis.incrby(uri :: STRING?, key :: ANY?, amount :: INTEGER?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.info,"apoc.redis.info(uri, {config}) | Execute the 'INFO' command","apoc.redis.info(uri :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.lrange,"apoc.redis.lrange(uri, key, start, stop, {config}) | Execute the 'LRANGE key start stop' command","apoc.redis.lrange(uri :: STRING?, key :: ANY?, start :: INTEGER?, stop :: INTEGER?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",null,null,false
procedure,apoc.redis.persist,"apoc.redis.persist(uri, key, {config}) | Execute the 'PERSIST key' command","apoc.redis.persist(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.redis.pexpire,"apoc.redis.pexpire(uri, key, time, isExpireAt {config}) | Execute the 'PEXPIRE key time' command, or the 'PEPXPIREAT' if isExpireAt=true","apoc.redis.pexpire(uri :: STRING?, key :: ANY?, time :: INTEGER?, isExpireAt :: BOOLEAN?, config = {} :: MAP?) :: (value :: BOOLEAN?)",null,null,false
procedure,apoc.redis.pop,"apoc.redis.pop(uri, key, {config}) | Execute the 'LPOP key' command, or the 'RPOP' if config right=true (default)","apoc.redis.pop(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.pttl,"apoc.redis.pttl(uri, key, {config}) | Execute the 'PTTL key' command","apoc.redis.pttl(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.push,"apoc.redis.push(uri, key, values, {config}) | Execute the 'LPUSH key field values' command, or the 'RPUSH' if config right=true (default)","apoc.redis.push(uri :: STRING?, key :: ANY?, value :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.sadd,"apoc.redis.sadd(uri, key, members, {config}) | Execute the 'SADD key members' command","apoc.redis.sadd(uri :: STRING?, key :: ANY?, members :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.scard,"apoc.redis.scard(uri, key, {config}) | Execute the 'SCARD key' command","apoc.redis.scard(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.smembers,"apoc.redis.smembers(uri, key, {config}) | Execute the 'SMEMBERS key' command","apoc.redis.smembers(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",null,null,false
procedure,apoc.redis.spop,"apoc.redis.spop(uri, key, {config}) | Execute the 'SPOP key' command","apoc.redis.spop(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",null,null,false
procedure,apoc.redis.sunion,"apoc.redis.sunion(uri, keys, {config}) | Execute the 'SUNION keys' command","apoc.redis.sunion(uri :: STRING?, keys :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",null,null,false
procedure,apoc.redis.zadd,"apoc.redis.zadd(uri, keys, scoresAndMembers, {config}) | Execute the 'ZADD key scoresAndMembers' command, where scoresAndMembers is a list of score,member,score,member,...","apoc.redis.zadd(uri :: STRING?, key :: ANY?, value :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.zcard,"apoc.redis.zcard(uri, key, {config}) | Execute the 'ZCARD key' command","apoc.redis.zcard(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.redis.zrangebyscore,"apoc.redis.zrangebyscore(uri, key, min, max, {config}) | Execute the 'ZRANGEBYSCORE key min max' command","apoc.redis.zrangebyscore(uri :: STRING?, key :: ANY?, min :: INTEGER?, max :: INTEGER?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",null,null,false
procedure,apoc.redis.zrem,"apoc.redis.zrem(uri, key, members, {config}) | Execute the 'ZREM key members' command","apoc.redis.zrem(uri :: STRING?, key :: ANY?, members :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",null,null,false
procedure,apoc.refactor.categorize,"apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it","apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID",null,null,true
procedure,apoc.refactor.cloneNodes,"apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties","apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?, withRelationships = false :: BOOLEAN?, skipProperties = [] :: LIST? OF STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",null,null,true
procedure,apoc.refactor.cloneNodesWithRelationships,"apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships","apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",null,null,true
procedure,apoc.refactor.cloneSubgraph,"apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.","apoc.refactor.cloneSubgraph(nodes :: LIST? OF NODE?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",null,null,true
procedure,apoc.refactor.cloneSubgraphFromPaths,"apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.","apoc.refactor.cloneSubgraphFromPaths(paths :: LIST? OF PATH?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",null,null,true
procedure,apoc.refactor.collapseNode,"apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship","apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",null,null,true
procedure,apoc.refactor.deleteAndReconnect,"apoc.refactor.deleteAndReconnect([pathLinkedList], [nodesToRemove], {config}) - Removes some nodes from a linked list","apoc.refactor.deleteAndReconnect(path :: PATH?, nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,true
procedure,apoc.refactor.extractNode,"apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships","apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",null,null,true
procedure,apoc.refactor.from,"apoc.refactor.from(rel, startNode) redirect relationship to use new start-node","apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",null,null,true
procedure,apoc.refactor.invert,apoc.refactor.invert(rel) inverts relationship direction,"apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",null,null,true
procedure,apoc.refactor.mergeNodes,"apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list","apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (node :: NODE?)",null,null,true
procedure,apoc.refactor.mergeRelationships,"apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list","apoc.refactor.mergeRelationships(rels :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (rel :: RELATIONSHIP?)",null,null,true
procedure,apoc.refactor.normalizeAsBoolean,"apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean","apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID",null,null,true
procedure,apoc.refactor.rename.label,"apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) | rename a label from 'oldLabel' to 'newLabel' for all nodes. If 'nodes' is provided renaming is applied to this set only","apoc.refactor.rename.label(oldLabel :: STRING?, newLabel :: STRING?, nodes = [] :: LIST? OF NODE?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",null,null,true
procedure,apoc.refactor.rename.nodeProperty,"apoc.refactor.rename.nodeProperty(oldName, newName, [nodes], {config}) | rename all node's property from 'oldName' to 'newName'. If 'nodes' is provided renaming is applied to this set only","apoc.refactor.rename.nodeProperty(oldName :: STRING?, newName :: STRING?, nodes = [] :: LIST? OF NODE?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",null,null,true
procedure,apoc.refactor.rename.type,"apoc.refactor.rename.type(oldType, newType, [rels], {config}) | rename all relationships with type 'oldType' to 'newType'. If 'rels' is provided renaming is applied to this set only","apoc.refactor.rename.type(oldType :: STRING?, newType :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",null,null,true
procedure,apoc.refactor.rename.typeProperty,"apoc.refactor.rename.typeProperty(oldName, newName, [rels], {config}) | rename all relationship's property from 'oldName' to 'newName'. If 'rels' is provided renaming is applied to this set only","apoc.refactor.rename.typeProperty(oldName :: STRING?, newName :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",null,null,true
procedure,apoc.refactor.setType,"apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type","apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",null,null,true
procedure,apoc.refactor.to,"  apoc.refactor.to(rel, endNode) redirect relationship to use new end-node","apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",null,null,true
procedure,apoc.schema.assert,"apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2...] pairings.","apoc.schema.assert(indexes :: MAP?, constraints :: MAP?, dropExisting = true :: BOOLEAN?) :: (label :: ANY?, key :: STRING?, keys :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)",null,null,true
procedure,apoc.schema.nodes,"CALL apoc.schema.nodes([config]) yield name, label, properties, status, type","apoc.schema.nodes(config = {} :: MAP?) :: (name :: STRING?, label :: ANY?, properties :: LIST? OF STRING?, status :: STRING?, type :: STRING?, failure :: STRING?, populationProgress :: FLOAT?, size :: INTEGER?, valuesSelectivity :: FLOAT?, userDescription :: STRING?)",null,null,true
procedure,apoc.schema.properties.distinct,"apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key","apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)",null,null,true
procedure,apoc.schema.properties.distinctCount,"apoc.schema.properties.distinctCount([label], [key]) YIELD label, key, value, count - quickly returns all distinct values and counts for a given key","apoc.schema.properties.distinctCount(label =  :: STRING?, key =  :: STRING?) :: (label :: STRING?, key :: STRING?, value :: ANY?, count :: INTEGER?)",null,null,true
procedure,apoc.schema.relationships,"CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status","apoc.schema.relationships(config = {} :: MAP?) :: (name :: STRING?, type :: ANY?, properties :: LIST? OF STRING?, status :: STRING?)",null,null,true
procedure,apoc.search.multiSearchReduced,"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.","apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",null,null,true
procedure,apoc.search.node,"Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.","apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.search.nodeAll,"Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.","apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",null,null,true
procedure,apoc.search.nodeAllReduced,"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH / = / <> / < / > ..., value ). All 'hits' are returned.","apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",null,null,true
procedure,apoc.search.nodeReduced,"Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.","apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",null,null,true
procedure,apoc.spatial.geocode,"apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)","apoc.spatial.geocode(location :: STRING?, maxResults = 100 :: INTEGER?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",null,null,true
procedure,apoc.spatial.geocodeOnce,"apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)","apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",null,null,true
procedure,apoc.spatial.reverseGeocode,"apoc.spatial.reverseGeocode(latitude,longitude) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)","apoc.spatial.reverseGeocode(latitude :: FLOAT?, longitude :: FLOAT?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",null,null,true
procedure,apoc.spatial.sortByDistance,apoc.spatial.sortByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order,"apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)",null,null,true
procedure,apoc.static.get,apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage,apoc.static.get(key :: STRING?) :: (value :: ANY?),null,null,false
procedure,apoc.static.list,apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage,"apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)",null,null,false
procedure,apoc.static.set,"apoc.static.set(name, value) - stores value under key for server lifetime storage, returns previously stored or configured value","apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)",null,null,false
procedure,apoc.stats.degrees,"","apoc.stats.degrees(types =  :: STRING?) :: (type :: STRING?, direction :: STRING?, total :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?)",null,null,true
procedure,apoc.systemdb.execute,"","apoc.systemdb.execute(DDL commands, either a string or a list of strings :: ANY?, params = {} :: MAP?) :: (row :: MAP?)",null,null,false
procedure,apoc.systemdb.graph,"","apoc.systemdb.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",null,null,false
procedure,apoc.text.doubleMetaphone,apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings,apoc.text.doubleMetaphone(value :: ANY?) :: (value :: STRING?),null,null,true
procedure,apoc.text.phonetic,apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings,apoc.text.phonetic(value :: ANY?) :: (value :: STRING?),null,null,true
procedure,apoc.text.phoneticDelta,"apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings","apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)",null,null,true
procedure,apoc.trigger.add,"add a trigger kernelTransaction under a name, in the kernelTransaction you can use {createdNodes}, {deletedNodes} etc., the selector is {phase:'before/after/rollback/afterAsync'} returns previous and new trigger information. Takes in an optional configuration.","apoc.trigger.add(name :: STRING?, kernelTransaction :: STRING?, selector :: MAP?, config = {} :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.trigger.list,list all installed triggers,"apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.trigger.pause,CALL apoc.trigger.pause(name) | it pauses the trigger,"apoc.trigger.pause(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.trigger.remove,"remove previously added trigger, returns trigger information","apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.trigger.removeAll,"removes all previously added trigger, returns trigger information","apoc.trigger.removeAll() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.trigger.resume,CALL apoc.trigger.resume(name) | it resumes the paused trigger,"apoc.trigger.resume(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",null,null,true
procedure,apoc.ttl.expire,"CALL apoc.ttl.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property","apoc.ttl.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID",null,null,false
procedure,apoc.ttl.expireIn,"CALL apoc.ttl.expireIn(node,timeDelta,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property","apoc.ttl.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID",null,null,false
procedure,apoc.util.sleep,"apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored",apoc.util.sleep(duration :: INTEGER?) :: VOID,null,null,true
procedure,apoc.util.validate,"apoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception","apoc.util.validate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: VOID",null,null,true
procedure,apoc.uuid.install,"CALL apoc.uuid.install(label, {addToExistingNodes: true/false, uuidProperty: 'uuid'}) yield label, installed, properties, batchComputationResult | it will add the uuid transaction handler
for the provided `label` and `uuidProperty`, in case the UUID handler is already present it will be replaced by the new one","apoc.uuid.install(label :: STRING?, config = {} :: MAP?) :: (batchComputationResult :: MAP?, label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",null,null,false
procedure,apoc.uuid.list,"CALL apoc.uuid.list() yield label, installed, properties | provides a list of all the uuid handlers installed with the related configuration","apoc.uuid.list() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",null,null,false
procedure,apoc.uuid.remove,"CALL apoc.uuid.remove(label) yield label, installed, properties | remove previously added uuid handler and returns uuid information. All the existing uuid properties are left as-is","apoc.uuid.remove(label :: STRING?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",null,null,false
procedure,apoc.uuid.removeAll,"CALL apoc.uuid.removeAll() yield label, installed, properties | it removes all previously added uuid handlers and returns uuids information. All the existing uuid properties are left as-is","apoc.uuid.removeAll() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",null,null,false
procedure,apoc.warmup.run,"apoc.warmup.run(loadProperties=false,loadDynamicProperties=false,loadIndexes=false) - quickly loads all nodes and rels into memory by skipping one page at a time","apoc.warmup.run(loadProperties = false :: BOOLEAN?, loadDynamicProperties = false :: BOOLEAN?, loadIndexes = false :: BOOLEAN?) :: (pageSize :: INTEGER?, totalTime :: INTEGER?, transactionWasTerminated :: BOOLEAN?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, relGroupsPerPage :: INTEGER?, relGroupsTotal :: INTEGER?, relGroupPages :: INTEGER?, relGroupsTime :: INTEGER?, propertiesLoaded :: BOOLEAN?, dynamicPropertiesLoaded :: BOOLEAN?, propsPerPage :: INTEGER?, propRecordsTotal :: INTEGER?, propPages :: INTEGER?, propsTime :: INTEGER?, stringPropsPerPage :: INTEGER?, stringPropRecordsTotal :: INTEGER?, stringPropPages :: INTEGER?, stringPropsTime :: INTEGER?, arrayPropsPerPage :: INTEGER?, arrayPropRecordsTotal :: INTEGER?, arrayPropPages :: INTEGER?, arrayPropsTime :: INTEGER?, indexesLoaded :: BOOLEAN?, indexPages :: INTEGER?, indexTime :: INTEGER?)",null,null,true
procedure,apoc.when,"apoc.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes read-only ifQuery or elseQuery with the given parameters","apoc.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",null,null,true
procedure,apoc.xml.import,Deprecated by apoc.import.xml,"apoc.xml.import(url :: STRING?, config = {} :: MAP?) :: (node :: NODE?)",null,null,true
function,apoc.agg.first,apoc.agg.first(value) - returns first value,apoc.agg.first(value :: ANY?) :: (ANY?),null,null,true
function,apoc.agg.graph,"apoc.agg.graph(path) - returns map of graph {nodes, relationships} of all distinct nodes and relationships",apoc.agg.graph(element :: ANY?) :: (MAP?),null,null,true
function,apoc.agg.last,apoc.agg.last(value) - returns last value,apoc.agg.last(value :: ANY?) :: (ANY?),null,null,true
function,apoc.agg.maxItems,"apoc.agg.maxItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the maximum value present, and `items` are all items with the same value. The number of items can be optionally limited.","apoc.agg.maxItems(item :: ANY?, value :: ANY?, groupLimit = -1 :: INTEGER?) :: (ANY?)",null,null,true
function,apoc.agg.median,apoc.agg.median(number) - returns median for non-null numeric values,apoc.agg.median(value :: ANY?) :: (ANY?),null,null,true
function,apoc.agg.minItems,"apoc.agg.minItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the minimum value present, and `items` are all items with the same value. The number of items can be optionally limited.","apoc.agg.minItems(item :: ANY?, value :: ANY?, groupLimit = -1 :: INTEGER?) :: (ANY?)",null,null,true
function,apoc.agg.nth,"apoc.agg.nth(value,offset) - returns value of nth row (or -1 for last)","apoc.agg.nth(value :: ANY?, value :: INTEGER?) :: (ANY?)",null,null,true
function,apoc.agg.percentiles,"apoc.agg.percentiles(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns given percentiles for values","apoc.agg.percentiles(value :: NUMBER?, percentiles = [0.5, 0.75, 0.9, 0.95, 0.99] :: LIST? OF FLOAT?) :: (LIST? OF ANY?)",null,null,true
function,apoc.agg.product,apoc.agg.product(number) - returns given product for non-null values,apoc.agg.product(number :: NUMBER?) :: (NUMBER?),null,null,true
function,apoc.agg.slice,"apoc.agg.slice(value, start, length) - returns subset of non-null values, start is 0 based and length can be -1","apoc.agg.slice(value :: ANY?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.agg.statistics,"apoc.agg.statistics(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns numeric statistics (percentiles, min,minNonZero,max,total,mean,stdev) for values","apoc.agg.statistics(value :: NUMBER?, percentiles = [0.5, 0.75, 0.9, 0.95, 0.99] :: LIST? OF FLOAT?) :: (MAP?)",null,null,true
function,apoc.any.properties,"returns properties for virtual and real, nodes, rels and maps","apoc.any.properties(thing :: ANY?, keys = null :: LIST? OF STRING?) :: (MAP?)",null,null,true
function,apoc.any.property,"returns property for virtual and real, nodes, rels and maps","apoc.any.property(thing :: ANY?, key :: STRING?) :: (ANY?)",null,null,true
function,apoc.bitwise.op,"apoc.bitwise.op(60,'|',13) bitwise operations a & b, a | b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation","apoc.bitwise.op(a :: INTEGER?, operator :: STRING?, b :: INTEGER?) :: (INTEGER?)",null,null,true
function,apoc.coll.avg,"apoc.coll.avg([0.5,1,2.3])",apoc.coll.avg(numbers :: LIST? OF NUMBER?) :: (FLOAT?),null,null,true
function,apoc.coll.combinations,"apoc.coll.combinations(coll, minSelect, maxSelect:minSelect) - Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive","apoc.coll.combinations(coll :: LIST? OF ANY?, minSelect :: INTEGER?, maxSelect = -1 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.contains,"apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)","apoc.coll.contains(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.coll.containsAll,"apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)","apoc.coll.containsAll(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.coll.containsAllSorted,"apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)","apoc.coll.containsAllSorted(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.coll.containsDuplicates,apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements,apoc.coll.containsDuplicates(coll :: LIST? OF ANY?) :: (BOOLEAN?),null,null,true
function,apoc.coll.containsSorted,"apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)","apoc.coll.containsSorted(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.coll.different,apoc.coll.different(values) - returns true if values are different,apoc.coll.different(values :: LIST? OF ANY?) :: (BOOLEAN?),null,null,true
function,apoc.coll.disjunction,"apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists","apoc.coll.disjunction(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.dropDuplicateNeighbors,apoc.coll.dropDuplicateNeighbors(list) - remove duplicate consecutive objects in a list,apoc.coll.dropDuplicateNeighbors(list :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.duplicates,apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection,apoc.coll.duplicates(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.duplicatesWithCount,"apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)",apoc.coll.duplicatesWithCount(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.fill,"apoc.coll.fill(item, count) - returns a list with the given count of items","apoc.coll.fill(item :: STRING?, count :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.flatten,"apoc.coll.flatten(coll, [recursive]) - flattens list (nested if recursive is true)","apoc.coll.flatten(coll :: LIST? OF ANY?, recursive = false :: BOOLEAN?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.frequencies,"apoc.coll.frequencies(coll) - returns a list of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]`)",apoc.coll.frequencies(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.frequenciesAsMap,"apoc.coll.frequenciesAsMap(coll) - return a map of frequencies of the items in the collection, key `item`, value `count` (e.g., `{1:2, 2:1}`)",apoc.coll.frequenciesAsMap(coll :: LIST? OF ANY?) :: (MAP?),null,null,true
function,apoc.coll.indexOf,"apoc.coll.indexOf(coll, value) | position of value in the list","apoc.coll.indexOf(coll :: LIST? OF ANY?, value :: ANY?) :: (INTEGER?)",null,null,true
function,apoc.coll.insert,"apoc.coll.insert(coll, index, value) | insert value at index","apoc.coll.insert(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.insertAll,"apoc.coll.insertAll(coll, index, values) | insert values at index","apoc.coll.insertAll(coll :: LIST? OF ANY?, index :: INTEGER?, values :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.intersection,"apoc.coll.intersection(first, second) - returns the unique intersection of the two lists","apoc.coll.intersection(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.isEqualCollection,"apoc.coll.isEqualCollection(coll, values) return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)","apoc.coll.isEqualCollection(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.coll.max,"apoc.coll.max([0.5,1,2.3])",apoc.coll.max(values :: LIST? OF ANY?) :: (ANY?),null,null,true
function,apoc.coll.min,"apoc.coll.min([0.5,1,2.3])",apoc.coll.min(values :: LIST? OF ANY?) :: (ANY?),null,null,true
function,apoc.coll.occurrences,"apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection","apoc.coll.occurrences(coll :: LIST? OF ANY?, item :: ANY?) :: (INTEGER?)",null,null,true
function,apoc.coll.pairWithOffset,"apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset","apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.pairs,"apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] ",apoc.coll.pairs(list :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.pairsMin,"apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]",apoc.coll.pairsMin(list :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.partition,"apoc.coll.partition(list,batchSize)","apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.randomItem,"apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list",apoc.coll.randomItem(coll :: LIST? OF ANY?) :: (ANY?),null,null,true
function,apoc.coll.randomItems,"apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again","apoc.coll.randomItems(coll :: LIST? OF ANY?, itemCount :: INTEGER?, allowRepick = false :: BOOLEAN?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.remove,"apoc.coll.remove(coll, index, [length=1]) | remove range of values from index to length","apoc.coll.remove(coll :: LIST? OF ANY?, index :: INTEGER?, length = 1 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.removeAll,"apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed","apoc.coll.removeAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.reverse,apoc.coll.reverse(coll) - returns reversed list,apoc.coll.reverse(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.runningTotal,"apoc.coll.runningTotal(list1) - returns an accumulative array. For example apoc.coll.runningTotal([1,2,3.5]) return [1,3,6.5]",apoc.coll.runningTotal(list :: LIST? OF NUMBER?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.set,"apoc.coll.set(coll, index, value) | set index to value","apoc.coll.set(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.shuffle,apoc.coll.shuffle(coll) - returns the shuffled list,apoc.coll.shuffle(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.sort,apoc.coll.sort(coll) sort on Collections,apoc.coll.sort(coll :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.sortMaps,"apoc.coll.sortMaps([maps], 'name') - sort maps by property","apoc.coll.sortMaps(coll :: LIST? OF MAP?, prop :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.sortMulti,"apoc.coll.sortMulti(coll, ['^name','age'],[limit],[skip]) - sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip","apoc.coll.sortMulti(coll :: LIST? OF MAP?, orderFields = [] :: LIST? OF STRING?, limit = -1 :: INTEGER?, skip = 0 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.sortNodes,"apoc.coll.sortNodes([nodes], 'name') sort nodes by property","apoc.coll.sortNodes(coll :: LIST? OF NODE?, prop :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.sortText,apoc.coll.sortText(coll) sort on string based collections,"apoc.coll.sortText(coll :: LIST? OF STRING?, conf = {} :: MAP?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.subtract,"apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed","apoc.coll.subtract(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.sum,"apoc.coll.sum([0.5,1,2.3])",apoc.coll.sum(numbers :: LIST? OF NUMBER?) :: (FLOAT?),null,null,true
function,apoc.coll.sumLongs,"apoc.coll.sumLongs([1,3,3])",apoc.coll.sumLongs(numbers :: LIST? OF NUMBER?) :: (INTEGER?),null,null,true
function,apoc.coll.toSet,apoc.coll.toSet([list]) returns a unique list backed by a set,apoc.coll.toSet(values :: LIST? OF ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.coll.union,"apoc.coll.union(first, second) - creates the distinct union of the 2 lists","apoc.coll.union(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.unionAll,"apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists","apoc.coll.unionAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.coll.zip,"apoc.coll.zip([list1],[list2])","apoc.coll.zip(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (LIST? OF ANY?)",null,null,true
function,apoc.convert.fromJsonList,"apoc.convert.fromJsonList('[1,2,3]'[,'json-path', 'path-options'])","apoc.convert.fromJsonList(list :: STRING?, path =  :: STRING?, pathOptions = null :: LIST? OF STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.convert.fromJsonMap,"apoc.convert.fromJsonMap('{""a"":42,""b"":""foo"",""c"":[1,2,3]}'[,'json-path', 'path-options'])","apoc.convert.fromJsonMap(map :: STRING?, path =  :: STRING?, pathOptions = null :: LIST? OF STRING?) :: (MAP?)",null,null,true
function,apoc.convert.getJsonProperty,"apoc.convert.getJsonProperty(node,key[,'json-path', 'path-options']) - converts serialized JSON in property back to original object","apoc.convert.getJsonProperty(node :: NODE?, key :: STRING?, path =  :: STRING?, pathOptions = null :: LIST? OF STRING?) :: (ANY?)",null,null,true
function,apoc.convert.getJsonPropertyMap,"apoc.convert.getJsonPropertyMap(node,key[,'json-path', 'path-options']) - converts serialized JSON in property back to map","apoc.convert.getJsonPropertyMap(node :: NODE?, key :: STRING?, path =  :: STRING?, pathOptions = null :: LIST? OF STRING?) :: (MAP?)",null,null,true
function,apoc.convert.toBoolean,apoc.convert.toBoolean(value) | tries it's best to convert the value to a boolean,apoc.convert.toBoolean(bool :: ANY?) :: (BOOLEAN?),null,null,true
function,apoc.convert.toBooleanList,apoc.convert.toBooleanList(value) | tries it's best to convert the value to a list of booleans,apoc.convert.toBooleanList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toFloat,apoc.convert.toFloat(value) | tries it's best to convert the value to a float,apoc.convert.toFloat(object :: ANY?) :: (FLOAT?),null,null,true
function,apoc.convert.toIntList,apoc.convert.toIntList(value) | tries it's best to convert the value to a list of integers,apoc.convert.toIntList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toInteger,apoc.convert.toInteger(value) | tries it's best to convert the value to an integer,apoc.convert.toInteger(object :: ANY?) :: (INTEGER?),null,null,true
function,apoc.convert.toJson,"apoc.convert.toJson([1,2,3]) or toJson({a:42,b:""foo"",c:[1,2,3]}) or toJson(NODE/REL/PATH)",apoc.convert.toJson(value :: ANY?) :: (STRING?),null,null,true
function,apoc.convert.toList,apoc.convert.toList(value) | tries it's best to convert the value to a list,apoc.convert.toList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toMap,apoc.convert.toMap(value) | tries it's best to convert the value to a map,apoc.convert.toMap(map :: ANY?) :: (MAP?),null,null,true
function,apoc.convert.toNode,apoc.convert.toNode(value) | tries it's best to convert the value to a node,apoc.convert.toNode(node :: ANY?) :: (NODE?),null,null,true
function,apoc.convert.toNodeList,apoc.convert.toNodeList(value) | tries it's best to convert the value to a list of nodes,apoc.convert.toNodeList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toRelationship,apoc.convert.toRelationship(value) | tries it's best to convert the value to a relationship,apoc.convert.toRelationship(relationship :: ANY?) :: (RELATIONSHIP?),null,null,true
function,apoc.convert.toRelationshipList,apoc.convert.toRelationshipList(value) | tries it's best to convert the value to a list of relationships,apoc.convert.toRelationshipList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toSet,apoc.convert.toSet(value) | tries it's best to convert the value to a set,apoc.convert.toSet(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.convert.toSortedJsonMap,"apoc.convert.toSortedJsonMap(node|map, ignoreCase:true) - returns a JSON map with keys sorted alphabetically, with optional case sensitivity","apoc.convert.toSortedJsonMap(value :: ANY?, ignoreCase = true :: BOOLEAN?) :: (STRING?)",null,null,true
function,apoc.convert.toString,apoc.convert.toString(value) | tries it's best to convert the value to a string,apoc.convert.toString(string :: ANY?) :: (STRING?),null,null,true
function,apoc.convert.toStringList,apoc.convert.toStringList(value) | tries it's best to convert the value to a list of strings,apoc.convert.toStringList(list :: ANY?) :: (LIST? OF ANY?),null,null,true
function,apoc.create.uuid,apoc.create.uuid() - creates an UUID,apoc.create.uuid() :: (STRING?),null,null,true
function,apoc.create.vNode,"apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node","apoc.create.vNode(label :: LIST? OF STRING?, props = {} :: MAP?) :: (NODE?)",null,null,true
function,apoc.create.vRelationship,"apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship","apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (RELATIONSHIP?)",null,null,true
function,apoc.create.virtual.fromNode,"apoc.create.virtual.fromNode(node, [propertyNames]) returns a virtual node built from an existing node with only the requested properties","apoc.create.virtual.fromNode(node :: NODE?, propertyNames :: LIST? OF STRING?) :: (NODE?)",null,null,true
function,apoc.cypher.runFirstColumn,use either apoc.cypher.runFirstColumnMany for a list return or apoc.cypher.runFirstColumnSingle for returning the first row of the first column,"apoc.cypher.runFirstColumn(cypher :: STRING?, params :: MAP?, expectMultipleValues = true :: BOOLEAN?) :: (ANY?)",null,null,true
function,apoc.cypher.runFirstColumnMany,"apoc.cypher.runFirstColumnMany(statement, params) - executes statement with given parameters, returns first column only collected into a list, params are available as identifiers","apoc.cypher.runFirstColumnMany(cypher :: STRING?, params :: MAP?) :: (LIST? OF ANY?)",null,null,true
function,apoc.cypher.runFirstColumnSingle,"apoc.cypher.runFirstColumnSingle(statement, params) - executes statement with given parameters, returns first element of the first column only, params are available as identifiers","apoc.cypher.runFirstColumnSingle(cypher :: STRING?, params :: MAP?) :: (ANY?)",null,null,true
function,apoc.data.domain,"apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null.",apoc.data.domain(url_or_email_address :: STRING?) :: (STRING?),null,null,true
function,apoc.data.url,"apoc.data.url('url') as {protocol,host,port,path,query,file,anchor,user} | turn URL into map structure",apoc.data.url(url :: STRING?) :: (MAP?),null,null,true
function,apoc.date.add,"apoc.date.add(12345, 'ms', -365, 'd') - given a timestamp in one time unit, adds a value of the specified time unit","apoc.date.add(time :: INTEGER?, unit :: STRING?, addValue :: INTEGER?, addUnit :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.date.convert,"apoc.date.convert(12345, 'ms', 'd') - convert a timestamp in one time unit into one of a different time unit","apoc.date.convert(time :: INTEGER?, unit :: STRING?, toUnit :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.date.convertFormat,"apoc.date.convertFormat('Tue, 14 May 2019 14:52:06 -0400', 'rfc_1123_date_time', 'iso_date_time') - convert a String of one date format into a String of another date format.","apoc.date.convertFormat(temporal :: STRING?, currentFormat :: STRING?, convertTo = yyyy-MM-dd :: STRING?) :: (STRING?)",null,null,true
function,apoc.date.currentTimestamp,"apoc.date.currentTimestamp() - returns System.currentTimeMillis() at the time it was called. The value is current throughout transaction execution, and is different from Cypher’s timestamp() function, which does not update within a transaction.",apoc.date.currentTimestamp() :: (INTEGER?),null,null,true
function,apoc.date.field,"apoc.date.field(12345,('ms|s|m|h|d|month|year'),('TZ')","apoc.date.field(time :: INTEGER?, unit = d :: STRING?, timezone = UTC :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.date.fields,"apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid","apoc.date.fields(date :: STRING?, pattern = yyyy-MM-dd HH:mm:ss :: STRING?) :: (MAP?)",null,null,true
function,apoc.date.format,"apoc.date.format(12345,('ms|s|m|h|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) - get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)","apoc.date.format(time :: INTEGER?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (STRING?)",null,null,true
function,apoc.date.fromISO8601,apoc.date.fromISO8601('yyyy-MM-ddTHH:mm:ss.SSSZ') - return number representation of time in EPOCH format,apoc.date.fromISO8601(time :: STRING?) :: (INTEGER?),null,null,true
function,apoc.date.parse,"apoc.date.parse('2012-12-23','ms|s|m|h|d','yyyy-MM-dd') - parse date string using the specified format into the specified time unit","apoc.date.parse(time :: STRING?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.date.parseAsZonedDateTime,"apoc.date.parseAsZonedDateTime('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') - parse date string using the specified format to specified timezone","apoc.date.parseAsZonedDateTime(time :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone = UTC :: STRING?) :: (DATETIME?)",null,null,true
function,apoc.date.systemTimezone,apoc.date.systemTimezone() - returns the system timezone display name,apoc.date.systemTimezone() :: (STRING?),null,null,true
function,apoc.date.toISO8601,"apoc.date.toISO8601(12345,('ms|s|m|h|d') - return string representation of time in ISO8601 format","apoc.date.toISO8601(time :: INTEGER?, unit = ms :: STRING?) :: (STRING?)",null,null,true
function,apoc.date.toYears,"toYears(timestamp) or toYears(date[,format]) - converts timestamp into floating point years","apoc.date.toYears(value :: ANY?, format = yyyy-MM-dd HH:mm:ss :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.diff.nodes,"","apoc.diff.nodes(leftNode :: NODE?, rightNode :: NODE?) :: (MAP?)",null,null,true
function,apoc.hashing.fingerprint,calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.,"apoc.hashing.fingerprint(some object :: ANY?, propertyExcludes = [] :: LIST? OF STRING?) :: (STRING?)",null,null,true
function,apoc.hashing.fingerprintGraph,calculate a checksum (md5) over a the full graph. Be aware that this function does use in-memomry datastructures depending on the size of your graph.,apoc.hashing.fingerprintGraph(propertyExcludes = [] :: LIST? OF STRING?) :: (STRING?),null,null,true
function,apoc.hashing.fingerprinting,calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.,"apoc.hashing.fingerprinting(some object :: ANY?, conf = {} :: MAP?) :: (STRING?)",null,null,true
function,apoc.json.path,"apoc.json.path('{json}' [,'json-path' , 'path-options'])","apoc.json.path(json :: STRING?, path = $ :: STRING?, pathOptions = null :: LIST? OF STRING?) :: (ANY?)",null,null,true
function,apoc.label.exists,"apoc.label.exists(element, label) - returns true or false related to label existance","apoc.label.exists(node :: ANY?, label :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.map.clean,"apoc.map.clean(map,[skip,keys],[skip,values]) yield map filters the keys and values contained in those lists, good for data cleaning from CSV/JSON","apoc.map.clean(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.flatten,"apoc.map.flatten(map, delimiter:'.') yield map - flattens nested items in map using dot notation","apoc.map.flatten(map :: MAP?, delimiter = . :: STRING?) :: (MAP?)",null,null,true
function,apoc.map.fromLists,"apoc.map.fromLists([keys],[values])","apoc.map.fromLists(keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.fromNodes,"apoc.map.fromNodes(label, property)","apoc.map.fromNodes(label :: STRING?, property :: STRING?) :: (MAP?)",null,null,true
function,apoc.map.fromPairs,"apoc.map.fromPairs([[key,value],[key2,value2],...])",apoc.map.fromPairs(pairs :: LIST? OF LIST? OF ANY?) :: (MAP?),null,null,true
function,apoc.map.fromValues,"apoc.map.fromValues([key1,value1,key2,value2,...])",apoc.map.fromValues(values :: LIST? OF ANY?) :: (MAP?),null,null,true
function,apoc.map.get,"apoc.map.get(map,key,[default],[fail=true]) - returns value for key or throws exception if key doesn't exist and no default given","apoc.map.get(map :: MAP?, key :: STRING?, value = null :: ANY?, fail = true :: BOOLEAN?) :: (ANY?)",null,null,true
function,apoc.map.groupBy,"apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values","apoc.map.groupBy(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)",null,null,true
function,apoc.map.groupByMulti,"apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values","apoc.map.groupByMulti(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)",null,null,true
function,apoc.map.merge,"apoc.map.merge(first,second) - merges two maps","apoc.map.merge(first :: MAP?, second :: MAP?) :: (MAP?)",null,null,true
function,apoc.map.mergeList,apoc.map.mergeList([{maps}]) yield value - merges all maps in the list into one,apoc.map.mergeList(maps :: LIST? OF MAP?) :: (MAP?),null,null,true
function,apoc.map.mget,"apoc.map.mget(map,key,[defaults],[fail=true])  - returns list of values for keys or throws exception if one of the key doesn't exist and no default value given at that position","apoc.map.mget(map :: MAP?, keys :: LIST? OF STRING?, values = [] :: LIST? OF ANY?, fail = true :: BOOLEAN?) :: (LIST? OF ANY?)",null,null,true
function,apoc.map.removeKey,"apoc.map.removeKey(map,key,{recursive:true/false}) - remove the key from the map (recursively if recursive is true)","apoc.map.removeKey(map :: MAP?, key :: STRING?, config = {} :: MAP?) :: (MAP?)",null,null,true
function,apoc.map.removeKeys,"apoc.map.removeKeys(map,[keys],{recursive:true/false}) - remove the keys from the map (recursively if recursive is true)","apoc.map.removeKeys(map :: MAP?, keys :: LIST? OF STRING?, config = {} :: MAP?) :: (MAP?)",null,null,true
function,apoc.map.setEntry,"apoc.map.setEntry(map,key,value)","apoc.map.setEntry(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)",null,null,true
function,apoc.map.setKey,"apoc.map.setKey(map,key,value)","apoc.map.setKey(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)",null,null,true
function,apoc.map.setLists,"apoc.map.setLists(map,[keys],[values])","apoc.map.setLists(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.setPairs,"apoc.map.setPairs(map,[[key1,value1],[key2,value2])","apoc.map.setPairs(map :: MAP?, pairs :: LIST? OF LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.setValues,"apoc.map.setValues(map,[key1,value1,key2,value2])","apoc.map.setValues(map :: MAP?, pairs :: LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.sortedProperties,"apoc.map.sortedProperties(map, ignoreCase:true) - returns a list of key/value list pairs, with pairs sorted by keys alphabetically, with optional case sensitivity","apoc.map.sortedProperties(map :: MAP?, ignoreCase = true :: BOOLEAN?) :: (LIST? OF ANY?)",null,null,true
function,apoc.map.submap,"apoc.map.submap(map,keys,[defaults],[fail=true])  - returns submap for keys or throws exception if one of the key doesn't exist and no default value given at that position","apoc.map.submap(map :: MAP?, keys :: LIST? OF STRING?, values = [] :: LIST? OF ANY?, fail = true :: BOOLEAN?) :: (MAP?)",null,null,true
function,apoc.map.unflatten,"apoc.map.unflatten(map, delimiter:'.') yield map - unflat from items separated by delimiter string to nested items (reverse of apoc.map.flatten function)","apoc.map.unflatten(map :: MAP?, delimiter = . :: STRING?) :: (MAP?)",null,null,true
function,apoc.map.updateTree,"apoc.map.updateTree(tree,key,[[value,{data}]]) returns map - adds the {data} map on each level of the nested tree, where the key-value pairs match","apoc.map.updateTree(tree :: MAP?, key :: STRING?, data :: LIST? OF LIST? OF ANY?) :: (MAP?)",null,null,true
function,apoc.map.values,"apoc.map.values(map, [key1,key2,key3,...],[addNullsForMissing]) returns list of values indicated by the keys","apoc.map.values(map :: MAP?, keys = [] :: LIST? OF STRING?, addNullsForMissing = false :: BOOLEAN?) :: (LIST? OF ANY?)",null,null,true
function,apoc.math.cosh,apoc.math.cosh(val) | returns the hyperbolic cosin,apoc.math.cosh(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.coth,apoc.math.coth(val) | returns the hyperbolic cotangent,apoc.math.coth(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.csch,apoc.math.csch(val) | returns the hyperbolic cosecant,apoc.math.csch(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.maxByte,apoc.math.maxByte() | return the maximum value an byte can have,apoc.math.maxByte() :: (INTEGER?),null,null,true
function,apoc.math.maxDouble,apoc.math.maxDouble() | return the largest positive finite value of type double,apoc.math.maxDouble() :: (FLOAT?),null,null,true
function,apoc.math.maxInt,apoc.math.maxInt() | return the maximum value an int can have,apoc.math.maxInt() :: (INTEGER?),null,null,true
function,apoc.math.maxLong,apoc.math.maxLong() | return the maximum value a long can have,apoc.math.maxLong() :: (INTEGER?),null,null,true
function,apoc.math.minByte,apoc.math.minByte() | return the minimum value an byte can have,apoc.math.minByte() :: (INTEGER?),null,null,true
function,apoc.math.minDouble,apoc.math.minDouble() | return the smallest positive nonzero value of type double,apoc.math.minDouble() :: (FLOAT?),null,null,true
function,apoc.math.minInt,apoc.math.minInt() | return the minimum value an int can have,apoc.math.minInt() :: (INTEGER?),null,null,true
function,apoc.math.minLong,apoc.math.minLong() | return the minimum value a long can have,apoc.math.minLong() :: (INTEGER?),null,null,true
function,apoc.math.round,"apoc.math.round(value,[prec],mode=[CEILING,FLOOR,UP,DOWN,HALF_EVEN,HALF_DOWN,HALF_UP,DOWN,UNNECESSARY])","apoc.math.round(value :: FLOAT?, precision = 0 :: INTEGER?, mode = HALF_UP :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.math.sech,apoc.math.sech(val) | returns the hyperbolic secant,apoc.math.sech(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.sigmoid,apoc.math.sigmoid(val) | returns the sigmoid value,apoc.math.sigmoid(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.sigmoidPrime,apoc.math.sigmoidPrime(val) | returns the sigmoid prime [ sigmoid(val) * (1 - sigmoid(val)) ],apoc.math.sigmoidPrime(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.sinh,apoc.math.sinh(val) | returns the hyperbolic sin,apoc.math.sinh(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.math.tanh,apoc.math.tanh(val) | returns the hyperbolic tangent,apoc.math.tanh(value :: FLOAT?) :: (FLOAT?),null,null,true
function,apoc.meta.cypher.isType,"apoc.meta.cypher.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF <TYPE>,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)","apoc.meta.cypher.isType(value :: ANY?, type :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.meta.cypher.type,"apoc.meta.cypher.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF <TYPE>,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)",apoc.meta.cypher.type(value :: ANY?) :: (STRING?),null,null,true
function,apoc.meta.cypher.types,apoc.meta.cypher.types(node-relationship-map)  - returns a map of keys to types,apoc.meta.cypher.types(properties :: ANY?) :: (MAP?),null,null,true
function,apoc.meta.isType,"apoc.meta.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)","apoc.meta.isType(value :: ANY?, type :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.meta.nodes.count,"apoc.meta.nodes.count([labels], $config) - Returns the sum of the nodes with a label present in the list.","apoc.meta.nodes.count(nodes = [] :: LIST? OF STRING?, config = {} :: MAP?) :: (INTEGER?)",null,null,true
function,apoc.meta.type,"apoc.meta.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)",apoc.meta.type(value :: ANY?) :: (STRING?),null,null,true
function,apoc.meta.typeName,"apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)",apoc.meta.typeName(value :: ANY?) :: (STRING?),null,null,true
function,apoc.meta.types,apoc.meta.types(node-relationship-map)  - returns a map of keys to types,apoc.meta.types(properties :: ANY?) :: (MAP?),null,null,true
function,apoc.node.degree,"apoc.node.degree(node, rel-direction-pattern) - returns total degrees of the given relationships in the pattern, can use '>' or '<' for all outgoing or incoming relationships","apoc.node.degree(node :: NODE?, types =  :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.node.degree.in,"apoc.node.degree.in(node, relationshipName) - returns total number number of incoming relationships","apoc.node.degree.in(node :: NODE?, types =  :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.node.degree.out,"apoc.node.degree.out(node, relationshipName) - returns total number number of outgoing relationships","apoc.node.degree.out(node :: NODE?, types =  :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.node.id,returns id for (virtual) nodes,apoc.node.id(node :: NODE?) :: (INTEGER?),null,null,true
function,apoc.node.labels,returns labels for (virtual) nodes,apoc.node.labels(node :: NODE?) :: (LIST? OF ANY?),null,null,true
function,apoc.node.relationship.exists,"apoc.node.relationship.exists(node, rel-direction-pattern) - returns true when the node has the relationships of the pattern","apoc.node.relationship.exists(node :: NODE?, types =  :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.node.relationship.types,"apoc.node.relationship.types(node, rel-direction-pattern) - returns a list of distinct relationship types","apoc.node.relationship.types(node :: NODE?, types =  :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.node.relationships.exist,"apoc.node.relationships.exist(node, rel-direction-pattern) - returns a map with rel-pattern, boolean for the given relationship patterns","apoc.node.relationships.exist(node :: NODE?, types =  :: STRING?) :: (MAP?)",null,null,true
function,apoc.nodes.connected,"apoc.nodes.connected(start, end, rel-direction-pattern) - returns true when the node is connected to the other node, optimized for dense nodes","apoc.nodes.connected(start :: NODE?, start :: NODE?, types =  :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.nodes.isDense,apoc.nodes.isDense(node) - returns true if it is a dense node,apoc.nodes.isDense(node :: NODE?) :: (BOOLEAN?),null,null,true
function,apoc.nodes.relationship.types,"apoc.nodes.relationship.types(node|nodes|id|[ids], rel-direction-pattern) - returns a list of maps where each one has two fields: `node` which is the node subject of the analysis and `types` which is a list of distinct relationship types","apoc.nodes.relationship.types(ids :: ANY?, types =  :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.nodes.relationships.exist,"apoc.nodes.relationships.exist(node|nodes|id|[ids], rel-direction-pattern) - returns a list of maps where each one has two fields: `node` which is the node subject of the analysis and `exists` which is a map with rel-pattern, boolean for the given relationship patterns","apoc.nodes.relationships.exist(ids :: ANY?, types =  :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.number.arabicToRoman,apoc.number.arabicToRoman(number)  | convert arabic numbers to roman,apoc.number.arabicToRoman(number :: ANY?) :: (STRING?),null,null,true
function,apoc.number.exact.add,"apoc.number.exact.add(stringA,stringB) - return the sum's result of two large numbers","apoc.number.exact.add(stringA :: STRING?, stringB :: STRING?) :: (STRING?)",null,null,true
function,apoc.number.exact.div,"apoc.number.exact.div(stringA,stringB,[prec],[roundingModel]) - return the division's result of two large numbers","apoc.number.exact.div(stringA :: STRING?, stringB :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (STRING?)",null,null,true
function,apoc.number.exact.mul,"apoc.number.exact.mul(stringA,stringB,[prec],[roundingModel]) - return the multiplication's result of two large numbers ","apoc.number.exact.mul(stringA :: STRING?, stringB :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (STRING?)",null,null,true
function,apoc.number.exact.sub,"apoc.number.exact.sub(stringA,stringB) - return the substraction's of two large numbers","apoc.number.exact.sub(stringA :: STRING?, stringB :: STRING?) :: (STRING?)",null,null,true
function,apoc.number.exact.toExact,apoc.number.exact.toExact(number) - return the exact value,apoc.number.exact.toExact(number :: INTEGER?) :: (INTEGER?),null,null,true
function,apoc.number.exact.toFloat,"apoc.number.exact.toFloat(string,[prec],[roundingMode]) - return the Float value of a large number","apoc.number.exact.toFloat(stringA :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.number.exact.toInteger,"apoc.number.exact.toInteger(string,[prec],[roundingMode]) - return the Integer value of a large number","apoc.number.exact.toInteger(stringA :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.number.format,apoc.number.format(number)  | format a long or double using the default system pattern and language to produce a string,"apoc.number.format(number :: ANY?, pattern =  :: STRING?, lang =  :: STRING?) :: (STRING?)",null,null,true
function,apoc.number.parseFloat,apoc.number.parseFloat(text)  | parse a text using the default system pattern and language to produce a double,"apoc.number.parseFloat(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.number.parseInt,apoc.number.parseInt(text)  | parse a text using the default system pattern and language to produce a long,"apoc.number.parseInt(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.number.romanToArabic,apoc.number.romanToArabic(romanNumber)  | convert roman numbers to arabic,apoc.number.romanToArabic(romanNumber :: STRING?) :: (NUMBER?),null,null,true
function,apoc.path.combine,"apoc.path.combine(path1, path2) - combines the paths into one if the connecting node matches","apoc.path.combine(first :: PATH?, second :: PATH?) :: (PATH?)",null,null,true
function,apoc.path.create,"apoc.path.create(startNode,[rels]) - creates a path instance of the given elements","apoc.path.create(startNode :: NODE?, rels = [] :: LIST? OF RELATIONSHIP?) :: (PATH?)",null,null,true
function,apoc.path.elements,apoc.path.elements(path) - returns a list of node-relationship-node-...,apoc.path.elements(path :: PATH?) :: (LIST? OF ANY?),null,null,true
function,apoc.path.slice,"apoc.path.slice(path, [offset], [length]) - creates a sub-path with the given offset and length","apoc.path.slice(path :: PATH?, offset = 0 :: INTEGER?, length = -1 :: INTEGER?) :: (PATH?)",null,null,true
function,apoc.rel.endNode,returns endNode for (virtual) relationships,apoc.rel.endNode(rel :: RELATIONSHIP?) :: (NODE?),null,null,true
function,apoc.rel.id,returns id for (virtual) relationships,apoc.rel.id(rel :: RELATIONSHIP?) :: (INTEGER?),null,null,true
function,apoc.rel.startNode,returns startNode for (virtual) relationships,apoc.rel.startNode(rel :: RELATIONSHIP?) :: (NODE?),null,null,true
function,apoc.rel.type,returns type for (virtual) relationships,apoc.rel.type(rel :: RELATIONSHIP?) :: (STRING?),null,null,true
function,apoc.schema.node.constraintExists,"RETURN apoc.schema.node.constraintExists(labelName, propertyNames)","apoc.schema.node.constraintExists(labelName :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.schema.node.indexExists,"RETURN apoc.schema.node.indexExists(labelName, propertyNames)","apoc.schema.node.indexExists(labelName :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.schema.relationship.constraintExists,"RETURN apoc.schema.relationship.constraintExists(type, propertyNames)","apoc.schema.relationship.constraintExists(type :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.schema.relationship.indexExists,"RETURN apoc.schema.relationship.indexExists(relName, propertyNames)","apoc.schema.relationship.indexExists(labelName :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.scoring.existence,"apoc.scoring.existence(5, true) returns the provided score if true, 0 if false","apoc.scoring.existence(score :: INTEGER?, exists :: BOOLEAN?) :: (FLOAT?)",null,null,true
function,apoc.scoring.pareto,"apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs","apoc.scoring.pareto(minimumThreshold :: INTEGER?, eightyPercentValue :: INTEGER?, maximumValue :: INTEGER?, score :: INTEGER?) :: (FLOAT?)",null,null,true
function,apoc.static.get,apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage,apoc.static.get(key :: STRING?) :: (ANY?),null,null,false
function,apoc.static.getAll,apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage,apoc.static.getAll(prefix :: STRING?) :: (MAP?),null,null,false
function,apoc.temporal.format,"apoc.temporal.format(input, format) | Format a temporal value","apoc.temporal.format(temporal :: ANY?, format = yyyy-MM-dd :: STRING?) :: (STRING?)",null,null,true
function,apoc.temporal.formatDuration,"apoc.temporal.formatDuration(input, format) | Format a Duration","apoc.temporal.formatDuration(input :: ANY?, format :: STRING?) :: (STRING?)",null,null,true
function,apoc.temporal.toZonedTemporal,"apoc.temporal.toZonedTemporal('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') parse date string using the specified format to specified timezone","apoc.temporal.toZonedTemporal(time :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone = UTC :: STRING?) :: (DATETIME?)",null,null,true
function,apoc.text.base64Decode,apoc.text.base64Decode(text) YIELD value - Decode Base64 encoded string,apoc.text.base64Decode(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.base64Encode,apoc.text.base64Encode(text) YIELD value - Encode a string with Base64,apoc.text.base64Encode(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.base64UrlDecode,apoc.text.base64UrlDecode(url) YIELD value - Decode Base64 encoded url,apoc.text.base64UrlDecode(url :: STRING?) :: (STRING?),null,null,true
function,apoc.text.base64UrlEncode,apoc.text.base64UrlEncode(text) YIELD value - Encode a url with Base64,apoc.text.base64UrlEncode(url :: STRING?) :: (STRING?),null,null,true
function,apoc.text.byteCount,"apoc.text.byteCount(text,[charset]) - return size of text in bytes","apoc.text.byteCount(text :: STRING?, charset = UTF-8 :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.text.bytes,"apoc.text.bytes(text,[charset]) - return bytes of the text","apoc.text.bytes(text :: STRING?, charset = UTF-8 :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.text.camelCase,apoc.text.camelCase(text) YIELD value - Convert a string to camelCase,apoc.text.camelCase(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.capitalize,apoc.text.capitalize(text) YIELD value - capitalise the first letter of the word,apoc.text.capitalize(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.capitalizeAll,apoc.text.capitalizeAll(text) YIELD value - capitalise the first letter of every word in the text,apoc.text.capitalizeAll(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.charAt,"apoc.text.charAt(text, index) - the decimal value of the character at the given index","apoc.text.charAt(text :: STRING?, index :: INTEGER?) :: (INTEGER?)",null,null,true
function,apoc.text.clean,apoc.text.clean(text) - strip the given string of everything except alpha numeric characters and convert it to lower case.,apoc.text.clean(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.code,apoc.text.code(codepoint) - Returns the unicode character of the given codepoint,apoc.text.code(codepoint :: INTEGER?) :: (STRING?),null,null,true
function,apoc.text.compareCleaned,"apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case.","apoc.text.compareCleaned(text1 :: STRING?, text2 :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.text.decapitalize,apoc.text.decapitalize(text) YIELD value - decapitalize the first letter of the word,apoc.text.decapitalize(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.decapitalizeAll,apoc.text.decapitalizeAll(text) YIELD value - decapitalize the first letter of all words,apoc.text.decapitalizeAll(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.distance,"apoc.text.distance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.","apoc.text.distance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.text.doubleMetaphone,apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value,apoc.text.doubleMetaphone(value :: STRING?) :: (STRING?),null,null,true
function,apoc.text.format,"apoc.text.format(text,[params],language) - sprintf format the string with the params given","apoc.text.format(text :: STRING?, params :: LIST? OF ANY?, language = en :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.fuzzyMatch,"apoc.text.fuzzyMatch(text1, text2) - check if 2 words can be matched in a fuzzy way. Depending on the length of the String it will allow more characters that needs to be edited to match the second String.","apoc.text.fuzzyMatch(text1 :: STRING?, text2 :: STRING?) :: (BOOLEAN?)",null,null,true
function,apoc.text.hammingDistance,"apoc.text.hammingDistance(text1, text2) - compare the given strings with the Hamming distance algorithm.","apoc.text.hammingDistance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.text.hexCharAt,"apoc.text.hexCharAt(text, index) - the hex value string of the character at the given index","apoc.text.hexCharAt(text :: STRING?, index :: INTEGER?) :: (STRING?)",null,null,true
function,apoc.text.hexValue,apoc.text.hexValue(value) - the hex value string of the given number,apoc.text.hexValue(value :: INTEGER?) :: (STRING?),null,null,true
function,apoc.text.indexOf,"apoc.text.indexOf(text, lookup, from=0, to=-1==len) - find the first occurence of the lookup string in the text, from inclusive, to exclusive, -1 if not found, null if text is null.","apoc.text.indexOf(text :: STRING?, lookup :: STRING?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (INTEGER?)",null,null,true
function,apoc.text.indexesOf,"apoc.text.indexesOf(text, lookup, from=0, to=-1==len) - finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.","apoc.text.indexesOf(text :: STRING?, lookup :: STRING?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.text.jaroWinklerDistance,"apoc.text.jaroWinklerDistance(text1, text2) - compare the given strings with the Jaro-Winkler distance algorithm.","apoc.text.jaroWinklerDistance(text1 :: STRING?, text2 :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.text.join,"apoc.text.join(['text1','text2',...], delimiter) - join the given strings with the given delimiter.","apoc.text.join(texts :: LIST? OF STRING?, delimiter :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.levenshteinDistance,"apoc.text.levenshteinDistance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.","apoc.text.levenshteinDistance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)",null,null,true
function,apoc.text.levenshteinSimilarity,"apoc.text.levenshteinSimilarity(text1, text2) - calculate the similarity (a value within 0 and 1) between two texts.","apoc.text.levenshteinSimilarity(text1 :: STRING?, text2 :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.text.lpad,"apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width","apoc.text.lpad(text :: STRING?, count :: INTEGER?, delim =   :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.phonetic,apoc.text.phonetic(text) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text,apoc.text.phonetic(value :: STRING?) :: (STRING?),null,null,true
function,apoc.text.random,"apoc.text.random(length, valid) YIELD value - generate a random string","apoc.text.random(length :: INTEGER?, valid = A-Za-z0-9 :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.regexGroups,"apoc.text.regexGroups(text, regex) - return all matching groups of the regex on the given text.","apoc.text.regexGroups(text :: STRING?, regex :: STRING?) :: (LIST? OF ANY?)",null,null,true
function,apoc.text.regreplace,"apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.","apoc.text.regreplace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.repeat,"apoc.text.repeat(item, count) - string multiplication","apoc.text.repeat(item :: STRING?, count :: INTEGER?) :: (STRING?)",null,null,true
function,apoc.text.replace,"apoc.text.replace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.","apoc.text.replace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.rpad,"apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width","apoc.text.rpad(text :: STRING?, count :: INTEGER?, delim =   :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.slug,"apoc.text.slug(text, delim) - slug the text with the given delimiter","apoc.text.slug(text :: STRING?, delim = - :: STRING?) :: (STRING?)",null,null,true
function,apoc.text.snakeCase,apoc.text.snakeCase(text) YIELD value - Convert a string to snake-case,apoc.text.snakeCase(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.sorensenDiceSimilarity,"apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) - compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag","apoc.text.sorensenDiceSimilarity(text1 :: STRING?, text2 :: STRING?, languageTag = en :: STRING?) :: (FLOAT?)",null,null,true
function,apoc.text.split,"apoc.text.split(text, regex, limit) - splits the given text around matches of the given regex.","apoc.text.split(text :: STRING?, regex :: STRING?, limit = 0 :: INTEGER?) :: (LIST? OF ANY?)",null,null,true
function,apoc.text.swapCase,apoc.text.swapCase(text) YIELD value - Swap the case of a string,apoc.text.swapCase(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.toCypher,"apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end}) | tries it's best to convert the value to a cypher-property-string","apoc.text.toCypher(value :: ANY?, config = {} :: MAP?) :: (STRING?)",null,null,true
function,apoc.text.toUpperCase,apoc.text.toUpperCase(text) YIELD value - Convert a string to UPPER_CASE,apoc.text.toUpperCase(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.upperCamelCase,apoc.text.upperCamelCase(text) YIELD value - Convert a string to camelCase,apoc.text.upperCamelCase(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.urldecode,apoc.text.urldecode(text) - return the urldecoded text,apoc.text.urldecode(text :: STRING?) :: (STRING?),null,null,true
function,apoc.text.urlencode,apoc.text.urlencode(text) - return the urlencoded text,apoc.text.urlencode(text :: STRING?) :: (STRING?),null,null,true
function,apoc.trigger.nodesByLabel,"","apoc.trigger.nodesByLabel(labelEntries :: ANY?, label :: STRING?) :: (LIST? OF ANY?)",null,null,false
function,apoc.trigger.propertiesByKey,"","apoc.trigger.propertiesByKey(propertyEntries :: MAP?, key :: STRING?) :: (LIST? OF ANY?)",null,null,false
function,apoc.ttl.config,"",apoc.ttl.config() :: (MAP?),null,null,false
function,apoc.util.compress,"apoc.util.compress(string, {config}) | return a compressed byte[] in various format from a string","apoc.util.compress(data :: STRING?, config = {} :: MAP?) :: (BYTEARRAY?)",null,null,true
function,apoc.util.decompress,"apoc.util.decompress(compressed, {config}) | return a string from a compressed byte[] in various format","apoc.util.decompress(data :: BYTEARRAY?, config = {} :: MAP?) :: (STRING?)",null,null,true
function,apoc.util.md5,apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list,apoc.util.md5(values :: LIST? OF ANY?) :: (STRING?),null,null,true
function,apoc.util.sha1,apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list,apoc.util.sha1(values :: LIST? OF ANY?) :: (STRING?),null,null,true
function,apoc.util.sha256,apoc.util.sha256([values]) | computes the sha256 of the concatenation of all string values of the list,apoc.util.sha256(values :: LIST? OF ANY?) :: (STRING?),null,null,true
function,apoc.util.sha384,apoc.util.sha384([values]) | computes the sha384 of the concatenation of all string values of the list,apoc.util.sha384(values :: LIST? OF ANY?) :: (STRING?),null,null,true
function,apoc.util.sha512,apoc.util.sha512([values]) | computes the sha512 of the concatenation of all string values of the list,apoc.util.sha512(values :: LIST? OF ANY?) :: (STRING?),null,null,true
function,apoc.util.validatePredicate,"apoc.util.validatePredicate(predicate, message, params) | if the predicate yields to true raise an exception else returns true, for use inside WHERE subclauses","apoc.util.validatePredicate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: (BOOLEAN?)",null,null,true
function,apoc.version,RETURN apoc.version() | return the current APOC installed version,apoc.version() :: (STRING?),null,null,true
function,apoc.xml.parse,"RETURN apoc.xml.parse(<xml string>, <xPath string>, config, false) AS value","apoc.xml.parse(data :: STRING?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (MAP?)",null,null,true